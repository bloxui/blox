// Code generated by gen-svg; DO NOT EDIT.

package svg

import (
	"strings"

	"github.com/plainkit/html"
)

// AnimateMotionAttrs holds the attributes for the animateMotion SVG element
type AnimateMotionAttrs struct {
	SvgGlobal                 SvgGlobalAttrs
	Accumulate                string
	Additive                  string
	Begin                     string
	By                        string
	CalcMode                  string
	Dur                       string
	End                       string
	ExternalResourcesRequired string
	Fill                      string
	From                      string
	Href                      string
	KeyPoints                 string
	KeySplines                string
	KeyTimes                  string
	Max                       string
	Min                       string
	Origin                    string
	Path                      string
	RepeatCount               string
	RepeatDur                 string
	RequiredExtensions        string
	RequiredFeatures          string
	RequiredFonts             string
	RequiredFormats           string
	Restart                   string
	Rotate                    string
	SystemLanguage            string
	To                        string
	Values                    string
}

// AnimateMotionArg interface for animateMotion element arguments
type AnimateMotionArg interface {
	applyAnimateMotion(*AnimateMotionAttrs, *[]html.Component)
}

// defaultAnimateMotionAttrs creates default attributes for animateMotion
func defaultAnimateMotionAttrs() *AnimateMotionAttrs {
	return &AnimateMotionAttrs{
		SvgGlobal: SvgGlobalAttrs{},
	}
}

// AnimateMotion creates an SVG animateMotion element (self-closing)
func AnimateMotion(args ...AnimateMotionArg) html.Node {
	a := defaultAnimateMotionAttrs()
	var kids []html.Component
	for _, ar := range args {
		ar.applyAnimateMotion(a, &kids)
	}
	return html.Node{
		Tag:   "animateMotion",
		Attrs: a,
		Void:  true,
	}
}

// Global applies global SVG attributes to animateMotion
func (g Global) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	g.do(&a.SvgGlobal)
}

// AccumulateOpt applies to AnimateMotion
func (o AccumulateOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Accumulate = o.v
}

// AdditiveOpt applies to AnimateMotion
func (o AdditiveOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Additive = o.v
}

// BeginOpt applies to AnimateMotion
func (o BeginOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Begin = o.v
}

// ByOpt applies to AnimateMotion
func (o ByOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.By = o.v
}

// CalcModeOpt applies to AnimateMotion
func (o CalcModeOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.CalcMode = o.v
}

// DurOpt applies to AnimateMotion
func (o DurOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Dur = o.v
}

// EndOpt applies to AnimateMotion
func (o EndOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.End = o.v
}

// ExternalResourcesRequiredOpt applies to AnimateMotion
func (o ExternalResourcesRequiredOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.ExternalResourcesRequired = o.v
}

// FillOpt applies to AnimateMotion
func (o FillOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Fill = o.v
}

// FromOpt applies to AnimateMotion
func (o FromOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.From = o.v
}

// HrefOpt applies to AnimateMotion
func (o HrefOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Href = o.v
}

// KeyPointsOpt applies to AnimateMotion
func (o KeyPointsOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.KeyPoints = o.v
}

// KeySplinesOpt applies to AnimateMotion
func (o KeySplinesOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.KeySplines = o.v
}

// KeyTimesOpt applies to AnimateMotion
func (o KeyTimesOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.KeyTimes = o.v
}

// MaxOpt applies to AnimateMotion
func (o MaxOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Max = o.v
}

// MinOpt applies to AnimateMotion
func (o MinOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Min = o.v
}

// OriginOpt applies to AnimateMotion
func (o OriginOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Origin = o.v
}

// PathOpt applies to AnimateMotion
func (o PathOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Path = o.v
}

// RepeatCountOpt applies to AnimateMotion
func (o RepeatCountOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.RepeatCount = o.v
}

// RepeatDurOpt applies to AnimateMotion
func (o RepeatDurOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.RepeatDur = o.v
}

// RequiredExtensionsOpt applies to AnimateMotion
func (o RequiredExtensionsOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.RequiredExtensions = o.v
}

// RequiredFeaturesOpt applies to AnimateMotion
func (o RequiredFeaturesOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.RequiredFeatures = o.v
}

// RequiredFontsOpt applies to AnimateMotion
func (o RequiredFontsOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.RequiredFonts = o.v
}

// RequiredFormatsOpt applies to AnimateMotion
func (o RequiredFormatsOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.RequiredFormats = o.v
}

// RestartOpt applies to AnimateMotion
func (o RestartOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Restart = o.v
}

// RotateOpt applies to AnimateMotion
func (o RotateOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Rotate = o.v
}

// SystemLanguageOpt applies to AnimateMotion
func (o SystemLanguageOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.SystemLanguage = o.v
}

// ToOpt applies to AnimateMotion
func (o ToOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.To = o.v
}

// ValuesOpt applies to AnimateMotion
func (o ValuesOpt) applyAnimateMotion(a *AnimateMotionAttrs, _ *[]html.Component) {
	a.Values = o.v
}

// writeAttrs writes the SVG attributes to the string builder
func (a *AnimateMotionAttrs) writeAttrs(sb *strings.Builder) {
	WriteSvgGlobal(sb, &a.SvgGlobal)
	if a.Accumulate != "" {
		SvgAttr(sb, "accumulate", a.Accumulate)
	}
	if a.Additive != "" {
		SvgAttr(sb, "additive", a.Additive)
	}
	if a.Begin != "" {
		SvgAttr(sb, "begin", a.Begin)
	}
	if a.By != "" {
		SvgAttr(sb, "by", a.By)
	}
	if a.CalcMode != "" {
		SvgAttr(sb, "calcMode", a.CalcMode)
	}
	if a.Dur != "" {
		SvgAttr(sb, "dur", a.Dur)
	}
	if a.End != "" {
		SvgAttr(sb, "end", a.End)
	}
	if a.ExternalResourcesRequired != "" {
		SvgAttr(sb, "externalResourcesRequired", a.ExternalResourcesRequired)
	}
	if a.Fill != "" {
		SvgAttr(sb, "fill", a.Fill)
	}
	if a.From != "" {
		SvgAttr(sb, "from", a.From)
	}
	if a.Href != "" {
		SvgAttr(sb, "href", a.Href)
	}
	if a.KeyPoints != "" {
		SvgAttr(sb, "keyPoints", a.KeyPoints)
	}
	if a.KeySplines != "" {
		SvgAttr(sb, "keySplines", a.KeySplines)
	}
	if a.KeyTimes != "" {
		SvgAttr(sb, "keyTimes", a.KeyTimes)
	}
	if a.Max != "" {
		SvgAttr(sb, "max", a.Max)
	}
	if a.Min != "" {
		SvgAttr(sb, "min", a.Min)
	}
	if a.Origin != "" {
		SvgAttr(sb, "origin", a.Origin)
	}
	if a.Path != "" {
		SvgAttr(sb, "path", a.Path)
	}
	if a.RepeatCount != "" {
		SvgAttr(sb, "repeatCount", a.RepeatCount)
	}
	if a.RepeatDur != "" {
		SvgAttr(sb, "repeatDur", a.RepeatDur)
	}
	if a.RequiredExtensions != "" {
		SvgAttr(sb, "requiredExtensions", a.RequiredExtensions)
	}
	if a.RequiredFeatures != "" {
		SvgAttr(sb, "requiredFeatures", a.RequiredFeatures)
	}
	if a.RequiredFonts != "" {
		SvgAttr(sb, "requiredFonts", a.RequiredFonts)
	}
	if a.RequiredFormats != "" {
		SvgAttr(sb, "requiredFormats", a.RequiredFormats)
	}
	if a.Restart != "" {
		SvgAttr(sb, "restart", a.Restart)
	}
	if a.Rotate != "" {
		SvgAttr(sb, "rotate", a.Rotate)
	}
	if a.SystemLanguage != "" {
		SvgAttr(sb, "systemLanguage", a.SystemLanguage)
	}
	if a.To != "" {
		SvgAttr(sb, "to", a.To)
	}
	if a.Values != "" {
		SvgAttr(sb, "values", a.Values)
	}
}
