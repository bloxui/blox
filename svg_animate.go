// Code generated by gen-svg; DO NOT EDIT.

package html

import (
	"strings"
)

// SvgAnimateAttrs holds the attributes for the animate SVG element
type SvgAnimateAttrs struct {
	GlobalAttrs
	Accumulate    string
	Additive      string
	AttributeName string
	AttributeType string
	Begin         string
	By            string
	CalcMode      string
	Dur           string
	End           string
	From          string
	KeySplines    string
	KeyTimes      string
	Max           string
	Min           string
	RepeatCount   string
	RepeatDur     string
	Restart       string
	To            string
	Values        string
}

// SvgAnimateArg interface for animate element arguments
type SvgAnimateArg interface {
	applyAnimate(*SvgAnimateAttrs, *[]Component)
}

// defaultSvgAnimateAttrs creates default attributes for animate
func defaultSvgAnimateAttrs() *SvgAnimateAttrs {
	return &SvgAnimateAttrs{
		GlobalAttrs: GlobalAttrs{},
	}
}

// SvgAnimate creates an SVG animate element (self-closing)
func SvgAnimate(args ...SvgAnimateArg) Node {
	a := defaultSvgAnimateAttrs()
	var kids []Component
	for _, ar := range args {
		ar.applyAnimate(a, &kids)
	}
	return Node{
		Tag:   "animate",
		Attrs: a,
		Void:  true,
	}
}

// Global applies global SVG attributes to animate
func (g Global) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	g.Do(&a.GlobalAttrs)
}

// AccumulateOpt applies to Animate
func (o AccumulateOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Accumulate = o.v
}

// AdditiveOpt applies to Animate
func (o AdditiveOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Additive = o.v
}

// AttributeNameOpt applies to Animate
func (o AttributeNameOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.AttributeName = o.v
}

// AttributeTypeOpt applies to Animate
func (o AttributeTypeOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.AttributeType = o.v
}

// BeginOpt applies to Animate
func (o BeginOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Begin = o.v
}

// ByOpt applies to Animate
func (o ByOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.By = o.v
}

// CalcModeOpt applies to Animate
func (o CalcModeOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.CalcMode = o.v
}

// DurOpt applies to Animate
func (o DurOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Dur = o.v
}

// EndOpt applies to Animate
func (o EndOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.End = o.v
}

// FromOpt applies to Animate
func (o FromOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.From = o.v
}

// KeySplinesOpt applies to Animate
func (o KeySplinesOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.KeySplines = o.v
}

// KeyTimesOpt applies to Animate
func (o KeyTimesOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.KeyTimes = o.v
}

// MaxOpt applies to Animate
func (o MaxOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Max = o.v
}

// MinOpt applies to Animate
func (o MinOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Min = o.v
}

// RepeatCountOpt applies to Animate
func (o RepeatCountOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.RepeatCount = o.v
}

// RepeatDurOpt applies to Animate
func (o RepeatDurOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.RepeatDur = o.v
}

// RestartOpt applies to Animate
func (o RestartOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Restart = o.v
}

// ToOpt applies to Animate
func (o ToOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.To = o.v
}

// ValuesOpt applies to Animate
func (o ValuesOpt) applyAnimate(a *SvgAnimateAttrs, _ *[]Component) {
	a.Values = o.v
}

// WriteAttrs writes the SVG attributes to the string builder
func (a *SvgAnimateAttrs) WriteAttrs(sb *strings.Builder) {
	WriteGlobal(sb, &a.GlobalAttrs)
	if a.Accumulate != "" {
		Attr(sb, "accumulate", a.Accumulate)
	}
	if a.Additive != "" {
		Attr(sb, "additive", a.Additive)
	}
	if a.AttributeName != "" {
		Attr(sb, "attributeName", a.AttributeName)
	}
	if a.AttributeType != "" {
		Attr(sb, "attributeType", a.AttributeType)
	}
	if a.Begin != "" {
		Attr(sb, "begin", a.Begin)
	}
	if a.By != "" {
		Attr(sb, "by", a.By)
	}
	if a.CalcMode != "" {
		Attr(sb, "calcMode", a.CalcMode)
	}
	if a.Dur != "" {
		Attr(sb, "dur", a.Dur)
	}
	if a.End != "" {
		Attr(sb, "end", a.End)
	}
	if a.From != "" {
		Attr(sb, "from", a.From)
	}
	if a.KeySplines != "" {
		Attr(sb, "keySplines", a.KeySplines)
	}
	if a.KeyTimes != "" {
		Attr(sb, "keyTimes", a.KeyTimes)
	}
	if a.Max != "" {
		Attr(sb, "max", a.Max)
	}
	if a.Min != "" {
		Attr(sb, "min", a.Min)
	}
	if a.RepeatCount != "" {
		Attr(sb, "repeatCount", a.RepeatCount)
	}
	if a.RepeatDur != "" {
		Attr(sb, "repeatDur", a.RepeatDur)
	}
	if a.Restart != "" {
		Attr(sb, "restart", a.Restart)
	}
	if a.To != "" {
		Attr(sb, "to", a.To)
	}
	if a.Values != "" {
		Attr(sb, "values", a.Values)
	}
}
