package html

import (
	"sort"
	"strings"
)

// This file is generated by gen-tags; DO NOT EDIT.
// Global HTML attributes structure and option constructors.

type GlobalAttrs struct {
	// Generated from global_attributes.json spec
	// Common core attributes
	Lang                  string
	Nonce                 string
	Part                  string
	ContentEditable       string
	Title                 string
	VirtualKeyboardPolicy string
	AutoCapitalize        string
	AccessKey             string
	AutoCorrect           string
	Class                 string
	Slot                  string
	Anchor                string
	Dir                   string
	Popover               string
	ExportParts           string
	Id                    string
	InputMode             string
	Is                    string
	EnterKeyHint          string

	// Style attribute as a single string
	Style string

	// Map attributes
	Aria   map[string]string // aria-*
	Data   map[string]string // data-*
	Events map[string]string // "onclick" -> "handler()"
	Custom map[string]string // custom attributes like hx-*, x-*, etc.

	// Pointers for tri-state values
	TabIndex                                             *int
	Spellcheck, Translate, Draggable, WritingSuggestions *string

	// Booleans
	Autofocus, Hidden, Inert bool
}

// Helper methods for setting attributes
func (g *GlobalAttrs) addClass(v string) {
	if v == "" {
		return
	}
	if g.Class == "" {
		g.Class = v
	} else {
		g.Class += " " + v
	}
}

func (g *GlobalAttrs) setStyle(style string) {
	g.Style = style
}

func (g *GlobalAttrs) setAria(k, v string) {
	if g.Aria == nil {
		g.Aria = map[string]string{}
	}
	g.Aria[k] = v
}

func (g *GlobalAttrs) setData(k, v string) {
	if g.Data == nil {
		g.Data = map[string]string{}
	}
	g.Data[k] = v
}

func (g *GlobalAttrs) setEvent(ev, handler string) {
	if g.Events == nil {
		g.Events = map[string]string{}
	}
	g.Events["on"+ev] = handler
}

func (g *GlobalAttrs) setCustom(k, v string) {
	if g.Custom == nil {
		g.Custom = map[string]string{}
	}
	g.Custom[k] = v
}

// Generated WriteGlobal function based on global_attributes.json spec
func WriteGlobal(sb *strings.Builder, g *GlobalAttrs) {
	if g.Lang != "" {
		Attr(sb, "lang", g.Lang)
	}
	if g.Style != "" {
		Attr(sb, "style", g.Style)
	}
	if g.Hidden {
		BoolAttr(sb, "hidden")
	}
	if g.InputMode != "" {
		Attr(sb, "inputmode", g.InputMode)
	}
	if g.Is != "" {
		Attr(sb, "is", g.Is)
	}
	if g.Part != "" {
		Attr(sb, "part", g.Part)
	}
	if g.Translate != nil {
		Attr(sb, "translate", *g.Translate)
	}
	if g.ExportParts != "" {
		Attr(sb, "exportparts", g.ExportParts)
	}
	if g.Inert {
		BoolAttr(sb, "inert")
	}
	if g.Nonce != "" {
		Attr(sb, "nonce", g.Nonce)
	}
	if g.Slot != "" {
		Attr(sb, "slot", g.Slot)
	}
	if g.VirtualKeyboardPolicy != "" {
		Attr(sb, "virtualkeyboardpolicy", g.VirtualKeyboardPolicy)
	}
	if g.AccessKey != "" {
		Attr(sb, "accesskey", g.AccessKey)
	}
	if g.AutoCorrect != "" {
		Attr(sb, "autocorrect", g.AutoCorrect)
	}
	if g.Autofocus {
		BoolAttr(sb, "autofocus")
	}
	if g.Draggable != nil {
		Attr(sb, "draggable", *g.Draggable)
	}
	if g.Dir != "" {
		Attr(sb, "dir", g.Dir)
	}
	if g.Id != "" {
		Attr(sb, "id", g.Id)
	}
	if g.WritingSuggestions != nil {
		Attr(sb, "writingsuggestions", *g.WritingSuggestions)
	}
	if g.Title != "" {
		Attr(sb, "title", g.Title)
	}
	if g.AutoCapitalize != "" {
		Attr(sb, "autocapitalize", g.AutoCapitalize)
	}
	if g.ContentEditable != "" {
		Attr(sb, "contenteditable", g.ContentEditable)
	}
	if g.Popover != "" {
		Attr(sb, "popover", g.Popover)
	}
	if g.Spellcheck != nil {
		Attr(sb, "spellcheck", *g.Spellcheck)
	}
	if g.TabIndex != nil {
		Attr(sb, "tabindex", itoa(*g.TabIndex))
	}
	if g.Class != "" {
		Attr(sb, "class", g.Class)
	}
	if g.EnterKeyHint != "" {
		Attr(sb, "enterkeyhint", g.EnterKeyHint)
	}
	if g.Anchor != "" {
		Attr(sb, "anchor", g.Anchor)
	}
	// Aria attributes
	for _, k := range sortedKeys(g.Aria) {
		Attr(sb, "aria-"+k, g.Aria[k])
	}

	// Data attributes
	for _, k := range sortedKeys(g.Data) {
		Attr(sb, "data-"+k, g.Data[k])
	}

	// Event handlers
	for _, evAttr := range sortedKeys(g.Events) {
		handler := g.Events[evAttr]
		if handler != "" {
			Attr(sb, evAttr, handler)
		}
	}

	// Custom attributes
	for _, k := range sortedKeys(g.Custom) {
		if v := g.Custom[k]; v != "" {
			Attr(sb, k, v)
		}
	}
}

func sortedKeys(m map[string]string) []string {
	if len(m) == 0 {
		return nil
	}
	keys := make([]string, 0, len(m))
	for k := range m {
		if k != "" {
			keys = append(keys, k)
		}
	}
	sort.Strings(keys)
	return keys
}

// Global option: one glue impl for all tags (methods are added in tag files)
type Global struct {
	f func(*GlobalAttrs)
}

func (g Global) do(ga *GlobalAttrs) {
	g.f(ga)
}

// Global attribute constructors
func AAccesskey(v string) Global {
	return Global{func(g *GlobalAttrs) { g.AccessKey = v }}
}

func ADraggable(b bool) Global {
	val := "false"
	if b {
		val = "true"
	}
	return Global{func(g *GlobalAttrs) { g.Draggable = &val }}
}

func AIsAttr(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Is = v }}
}

func ASpellcheck(b bool) Global {
	val := "false"
	if b {
		val = "true"
	}
	return Global{func(g *GlobalAttrs) { g.Spellcheck = &val }}
}

func ATitle(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Title = v }}
}

func ATranslate(b bool) Global {
	val := "no"
	if b {
		val = "yes"
	}
	return Global{func(g *GlobalAttrs) { g.Translate = &val }}
}

func AAutocorrect(v string) Global {
	return Global{func(g *GlobalAttrs) { g.AutoCorrect = v }}
}

func AAutofocus() Global {
	return Global{func(g *GlobalAttrs) { g.Autofocus = true }}
}

func AEnterkeyhint(v string) Global {
	return Global{func(g *GlobalAttrs) { g.EnterKeyHint = v }}
}

func AExportparts(v string) Global {
	return Global{func(g *GlobalAttrs) { g.ExportParts = v }}
}

func AInputmode(v string) Global {
	return Global{func(g *GlobalAttrs) { g.InputMode = v }}
}

func ASlot(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Slot = v }}
}

func ATabindex(i int) Global {
	return Global{func(g *GlobalAttrs) { g.TabIndex = &i }}
}

func ADir(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Dir = v }}
}

func ALang(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Lang = v }}
}

func AWritingsuggestions(b bool) Global {
	val := "false"
	if b {
		val = "true"
	}
	return Global{func(g *GlobalAttrs) { g.WritingSuggestions = &val }}
}

func AAutocapitalize(v string) Global {
	return Global{func(g *GlobalAttrs) { g.AutoCapitalize = v }}
}

func AHidden() Global {
	return Global{func(g *GlobalAttrs) { g.Hidden = true }}
}

func AStyle(style string) Global {
	return Global{func(g *GlobalAttrs) { g.setStyle(style) }}
}

func AClass(v string) Global {
	return Global{func(g *GlobalAttrs) { g.addClass(v) }}
}

func AContenteditable(v string) Global {
	return Global{func(g *GlobalAttrs) { g.ContentEditable = v }}
}

func AId(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Id = v }}
}

func AInert() Global {
	return Global{func(g *GlobalAttrs) { g.Inert = true }}
}

func ANonce(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Nonce = v }}
}

func APopover(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Popover = v }}
}

func AAnchor(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Anchor = v }}
}

func APart(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Part = v }}
}

func AVirtualkeyboardpolicy(v string) Global {
	return Global{func(g *GlobalAttrs) { g.VirtualKeyboardPolicy = v }}
}

// Map-like convenience functions
func AData(k, v string) Global {
	return Global{func(g *GlobalAttrs) { g.setData(k, v) }}
}

func AAria(k, v string) Global {
	return Global{func(g *GlobalAttrs) { g.setAria(k, v) }}
}

func AOn(ev, handler string) Global {
	return Global{func(g *GlobalAttrs) { g.setEvent(ev, handler) }}
}

func ACustom(k, v string) Global {
	return Global{func(g *GlobalAttrs) { g.setCustom(k, v) }}
}
