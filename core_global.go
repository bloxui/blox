package html

import (
	"sort"
	"strconv"
	"strings"
)

// This file is generated by gen-tags; DO NOT EDIT.
// Global HTML attributes structure and option constructors.

type GlobalAttrs struct {
	// Generated from wooorm global attributes
	// Common core attributes
	Class           string
	Accesskey       string
	Contenteditable string
	Dir             string
	Id              string
	Title           string

	// Style attribute as a single string
	Style string

	// Map attributes
	Aria   map[string]string // aria-*
	Data   map[string]string // data-*
	Events map[string]string // "onclick" -> "handler()"
	Custom map[string]string // custom attributes like hx-*, x-*, etc.

	// Pointers for tri-state values
	Tabindex   *int
	Draggable  *string
	Spellcheck *string

	// Booleans
	Hidden bool
}

// Helper methods for setting attributes
func (g *GlobalAttrs) addClass(v string) {
	if v == "" {
		return
	}
	if g.Class == "" {
		g.Class = v
	} else {
		g.Class += " " + v
	}
}

func (g *GlobalAttrs) setAria(k, v string) {
	if g.Aria == nil {
		g.Aria = map[string]string{}
	}
	g.Aria[k] = v
}

func (g *GlobalAttrs) setData(k, v string) {
	if g.Data == nil {
		g.Data = map[string]string{}
	}
	g.Data[k] = v
}

func (g *GlobalAttrs) setEvent(ev, handler string) {
	if g.Events == nil {
		g.Events = map[string]string{}
	}
	g.Events["on"+ev] = handler
}

func (g *GlobalAttrs) setCustom(k, v string) {
	if g.Custom == nil {
		g.Custom = map[string]string{}
	}
	g.Custom[k] = v
}

// Generated WriteGlobal function based on gostar global attributes
func WriteGlobal(sb *strings.Builder, g *GlobalAttrs) {
	if g.Class != "" {
		Attr(sb, "class", g.Class)
	}
	if g.Accesskey != "" {
		Attr(sb, "accesskey", g.Accesskey)
	}
	if g.Class != "" {
		Attr(sb, "class", g.Class)
	}
	if g.Contenteditable != "" {
		Attr(sb, "contenteditable", g.Contenteditable)
	}
	if g.Dir != "" {
		Attr(sb, "dir", g.Dir)
	}
	if g.Draggable != nil {
		Attr(sb, "draggable", *g.Draggable)
	}
	if g.Hidden {
		BoolAttr(sb, "hidden")
	}
	if g.Id != "" {
		Attr(sb, "id", g.Id)
	}
	if g.Spellcheck != nil {
		Attr(sb, "spellcheck", *g.Spellcheck)
	}
	if g.Style != "" {
		Attr(sb, "style", g.Style)
	}
	if g.Tabindex != nil {
		Attr(sb, "tabindex", strconv.Itoa(*g.Tabindex))
	}
	if g.Title != "" {
		Attr(sb, "title", g.Title)
	}
	// Aria attributes
	for _, k := range sortedKeys(g.Aria) {
		Attr(sb, "aria-"+k, g.Aria[k])
	}

	// Data attributes
	for _, k := range sortedKeys(g.Data) {
		Attr(sb, "data-"+k, g.Data[k])
	}

	// Event handlers
	for _, evAttr := range sortedKeys(g.Events) {
		handler := g.Events[evAttr]
		if handler != "" {
			Attr(sb, evAttr, handler)
		}
	}

	// Custom attributes
	for _, k := range sortedKeys(g.Custom) {
		if v := g.Custom[k]; v != "" {
			Attr(sb, k, v)
		}
	}
}

func sortedKeys(m map[string]string) []string {
	if len(m) == 0 {
		return nil
	}
	keys := make([]string, 0, len(m))
	for k := range m {
		if k != "" {
			keys = append(keys, k)
		}
	}
	sort.Strings(keys)
	return keys
}

// Global option: one glue impl for all tags (methods are added in tag files)
type Global struct {
	f func(*GlobalAttrs)
}

// Do applies the global attribute function to GlobalAttrs (public for SVG package integration)
func (g Global) Do(ga *GlobalAttrs) {
	g.f(ga)
}

// Note: applySvg method will be added via build tags or separate file
// to avoid circular imports between html and svg packages

// Global attribute constructors
func AClass(v string) Global {
	return Global{func(g *GlobalAttrs) { g.addClass(v) }}
}

func AAccesskey(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Accesskey = v }}
}

func AContenteditable(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Contenteditable = v }}
}

func ADir(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Dir = v }}
}

func ADraggable(b bool) Global {
	val := "false"
	if b {
		val = "true"
	}
	return Global{func(g *GlobalAttrs) { g.Draggable = &val }}
}

func AHidden() Global {
	return Global{func(g *GlobalAttrs) { g.Hidden = true }}
}

func AId(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Id = v }}
}

func ASpellcheck(b bool) Global {
	val := "false"
	if b {
		val = "true"
	}
	return Global{func(g *GlobalAttrs) { g.Spellcheck = &val }}
}

func AStyle(style string) Global {
	return Global{func(g *GlobalAttrs) { g.Style = style }}
}

func ATabindex(i int) Global {
	return Global{func(g *GlobalAttrs) { g.Tabindex = &i }}
}

func ATitle(v string) Global {
	return Global{func(g *GlobalAttrs) { g.Title = v }}
}

// Map-like convenience functions
func AData(k, v string) Global {
	return Global{func(g *GlobalAttrs) { g.setData(k, v) }}
}

func AAria(k, v string) Global {
	return Global{func(g *GlobalAttrs) { g.setAria(k, v) }}
}

func AOn(ev, handler string) Global {
	return Global{func(g *GlobalAttrs) { g.setEvent(ev, handler) }}
}

func ACustom(k, v string) Global {
	return Global{func(g *GlobalAttrs) { g.setCustom(k, v) }}
}
