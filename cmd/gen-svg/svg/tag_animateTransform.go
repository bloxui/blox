// Code generated by gen-svg; DO NOT EDIT.

package svg

import (
	"strings"

	"github.com/plainkit/html"
)

// AnimateTransformAttrs holds the attributes for the animateTransform SVG element
type AnimateTransformAttrs struct {
	SvgGlobal     SvgGlobalAttrs
	Accumulate    string
	Additive      string
	AttributeName string
	AttributeType string
	Begin         string
	By            string
	CalcMode      string
	Dur           string
	End           string
	From          string
	KeySplines    string
	KeyTimes      string
	Max           string
	Min           string
	RepeatCount   string
	RepeatDur     string
	Restart       string
	To            string
	Type          string
	Values        string
}

// AnimateTransformArg interface for animateTransform element arguments
type AnimateTransformArg interface {
	applyAnimateTransform(*AnimateTransformAttrs, *[]html.Component)
}

// defaultAnimateTransformAttrs creates default attributes for animateTransform
func defaultAnimateTransformAttrs() *AnimateTransformAttrs {
	return &AnimateTransformAttrs{
		SvgGlobal: SvgGlobalAttrs{},
	}
}

// AnimateTransform creates an SVG animateTransform element (self-closing)
func AnimateTransform(args ...AnimateTransformArg) html.Node {
	a := defaultAnimateTransformAttrs()
	var kids []html.Component
	for _, ar := range args {
		ar.applyAnimateTransform(a, &kids)
	}
	return html.Node{
		Tag:   "animateTransform",
		Attrs: a,
		Void:  true,
	}
}

// Global applies global SVG attributes to animateTransform
func (g Global) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	g.do(&a.SvgGlobal)
}

// AccumulateOpt applies to AnimateTransform
func (o AccumulateOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Accumulate = o.v
}

// AdditiveOpt applies to AnimateTransform
func (o AdditiveOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Additive = o.v
}

// AttributeNameOpt applies to AnimateTransform
func (o AttributeNameOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.AttributeName = o.v
}

// AttributeTypeOpt applies to AnimateTransform
func (o AttributeTypeOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.AttributeType = o.v
}

// BeginOpt applies to AnimateTransform
func (o BeginOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Begin = o.v
}

// ByOpt applies to AnimateTransform
func (o ByOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.By = o.v
}

// CalcModeOpt applies to AnimateTransform
func (o CalcModeOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.CalcMode = o.v
}

// DurOpt applies to AnimateTransform
func (o DurOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Dur = o.v
}

// EndOpt applies to AnimateTransform
func (o EndOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.End = o.v
}

// FromOpt applies to AnimateTransform
func (o FromOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.From = o.v
}

// KeySplinesOpt applies to AnimateTransform
func (o KeySplinesOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.KeySplines = o.v
}

// KeyTimesOpt applies to AnimateTransform
func (o KeyTimesOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.KeyTimes = o.v
}

// MaxOpt applies to AnimateTransform
func (o MaxOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Max = o.v
}

// MinOpt applies to AnimateTransform
func (o MinOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Min = o.v
}

// RepeatCountOpt applies to AnimateTransform
func (o RepeatCountOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.RepeatCount = o.v
}

// RepeatDurOpt applies to AnimateTransform
func (o RepeatDurOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.RepeatDur = o.v
}

// RestartOpt applies to AnimateTransform
func (o RestartOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Restart = o.v
}

// ToOpt applies to AnimateTransform
func (o ToOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.To = o.v
}

// TypeOpt applies to AnimateTransform
func (o TypeOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Type = o.v
}

// ValuesOpt applies to AnimateTransform
func (o ValuesOpt) applyAnimateTransform(a *AnimateTransformAttrs, _ *[]html.Component) {
	a.Values = o.v
}

// WriteAttrs writes the SVG attributes to the string builder
func (a *AnimateTransformAttrs) WriteAttrs(sb *strings.Builder) {
	WriteSvgGlobal(sb, &a.SvgGlobal)
	if a.Accumulate != "" {
		SvgAttr(sb, "accumulate", a.Accumulate)
	}
	if a.Additive != "" {
		SvgAttr(sb, "additive", a.Additive)
	}
	if a.AttributeName != "" {
		SvgAttr(sb, "attributeName", a.AttributeName)
	}
	if a.AttributeType != "" {
		SvgAttr(sb, "attributeType", a.AttributeType)
	}
	if a.Begin != "" {
		SvgAttr(sb, "begin", a.Begin)
	}
	if a.By != "" {
		SvgAttr(sb, "by", a.By)
	}
	if a.CalcMode != "" {
		SvgAttr(sb, "calcMode", a.CalcMode)
	}
	if a.Dur != "" {
		SvgAttr(sb, "dur", a.Dur)
	}
	if a.End != "" {
		SvgAttr(sb, "end", a.End)
	}
	if a.From != "" {
		SvgAttr(sb, "from", a.From)
	}
	if a.KeySplines != "" {
		SvgAttr(sb, "keySplines", a.KeySplines)
	}
	if a.KeyTimes != "" {
		SvgAttr(sb, "keyTimes", a.KeyTimes)
	}
	if a.Max != "" {
		SvgAttr(sb, "max", a.Max)
	}
	if a.Min != "" {
		SvgAttr(sb, "min", a.Min)
	}
	if a.RepeatCount != "" {
		SvgAttr(sb, "repeatCount", a.RepeatCount)
	}
	if a.RepeatDur != "" {
		SvgAttr(sb, "repeatDur", a.RepeatDur)
	}
	if a.Restart != "" {
		SvgAttr(sb, "restart", a.Restart)
	}
	if a.To != "" {
		SvgAttr(sb, "to", a.To)
	}
	if a.Type != "" {
		SvgAttr(sb, "type", a.Type)
	}
	if a.Values != "" {
		SvgAttr(sb, "values", a.Values)
	}
}
