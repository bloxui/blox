package generator

import (
	"fmt"
	"strings"

	"github.com/plainkit/html/cmd/gen-tags/internal/spec"
)

// GlobalGenerator handles generation of the core_global.go file
type GlobalGenerator struct{}

// NewGlobalGenerator creates a new global generator
func NewGlobalGenerator() *GlobalGenerator {
	return &GlobalGenerator{}
}

// GenerateSource creates the source code for core_global.go
func (g *GlobalGenerator) GenerateSource(globalAttrs []spec.Attribute) string {
	var sb strings.Builder

	sb.WriteString("package html\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"sort\"\n")
	sb.WriteString("\t\"strconv\"\n")
	sb.WriteString("\t\"strings\"\n")
	sb.WriteString(")\n\n")
	sb.WriteString("// This file is generated by gen-tags; DO NOT EDIT.\n")
	sb.WriteString("// Global HTML attributes structure and option constructors.\n\n")

	g.generateGlobalAttrsStruct(&sb, globalAttrs)

	g.generateHelperMethods(&sb)

	g.generateWriteGlobalFunction(&sb, globalAttrs)

	g.generateSortedKeysFunction(&sb)

	g.generateGlobalOptionType(&sb)

	g.generateGlobalConstructors(&sb, globalAttrs)

	g.generateConvenienceFunctions(&sb)

	return sb.String()
}

func (g *GlobalGenerator) generateGlobalAttrsStruct(sb *strings.Builder, globalAttrs []spec.Attribute) {
	sb.WriteString("type GlobalAttrs struct {\n")
	sb.WriteString("\t// Generated from wooorm global attributes\n")
	sb.WriteString("\t// Common core attributes\n")

	stringAttrs := []string{}
	boolAttrs := []string{}
	pointerStringAttrs := []string{"spellcheck", "translate", "draggable", "writingsuggestions"}
	pointerIntAttrs := []string{"tabindex"}

	for _, attr := range globalAttrs {
		attrName := attr.Attr
		fieldName := attr.Field

		if g.contains(pointerStringAttrs, attrName) {
		} else if g.contains(pointerIntAttrs, attrName) {
		} else if g.contains([]string{"hidden", "inert", "autofocus", "itemscope"}, attrName) {
			boolAttrs = append(boolAttrs, fieldName)
		} else if attrName == "style" {
		} else {
			stringAttrs = append(stringAttrs, fieldName)
		}
	}

	// Always include essential fields
	sb.WriteString("\tClass string\n")

	for _, field := range stringAttrs {
		if field != "Class" { // Avoid duplicate
			fmt.Fprintf(sb, "\t%s string\n", field)
		}
	}

	sb.WriteString("\n\t// Style attribute as a single string\n")
	sb.WriteString("\tStyle string\n\n")

	sb.WriteString("\t// Map attributes\n")
	sb.WriteString("\tAria   map[string]string // aria-*\n")
	sb.WriteString("\tData   map[string]string // data-*\n")
	sb.WriteString("\tEvents map[string]string // \"onclick\" -> \"handler()\"\n")
	sb.WriteString("\tCustom map[string]string // custom attributes like hx-*, x-*, etc.\n\n")

	sb.WriteString("\t// Pointers for tri-state values\n")

	var pointerIntFields []string
	var pointerStringFields []string

	for _, attr := range globalAttrs {
		attrName := attr.Attr
		fieldName := attr.Field

		if g.contains(pointerIntAttrs, attrName) {
			pointerIntFields = append(pointerIntFields, fieldName+" *int")
		} else if g.contains(pointerStringAttrs, attrName) {
			pointerStringFields = append(pointerStringFields, fieldName+" *string")
		}
	}

	for _, field := range pointerIntFields {
		fmt.Fprintf(sb, "\t%s\n", field)
	}

	for _, field := range pointerStringFields {
		fmt.Fprintf(sb, "\t%s\n", field)
	}
	sb.WriteString("\n")

	sb.WriteString("\t// Booleans\n")
	for i, field := range boolAttrs {
		if i == 0 {
			fmt.Fprintf(sb, "\t%s", field)
		} else {
			fmt.Fprintf(sb, ", %s", field)
		}
	}
	if len(boolAttrs) > 0 {
		sb.WriteString(" bool\n")
	}

	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateHelperMethods(sb *strings.Builder) {
	sb.WriteString("// Helper methods for setting attributes\n")
	sb.WriteString("func (g *GlobalAttrs) addClass(v string) {\n")
	sb.WriteString("\tif v == \"\" {\n")
	sb.WriteString("\t\treturn\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tif g.Class == \"\" {\n")
	sb.WriteString("\t\tg.Class = v\n")
	sb.WriteString("\t} else {\n")
	sb.WriteString("\t\tg.Class += \" \" + v\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setAria(k, v string) {\n")
	sb.WriteString("\tif g.Aria == nil {\n")
	sb.WriteString("\t\tg.Aria = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Aria[k] = v\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setData(k, v string) {\n")
	sb.WriteString("\tif g.Data == nil {\n")
	sb.WriteString("\t\tg.Data = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Data[k] = v\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setEvent(ev, handler string) {\n")
	sb.WriteString("\tif g.Events == nil {\n")
	sb.WriteString("\t\tg.Events = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Events[\"on\"+ev] = handler\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setCustom(k, v string) {\n")
	sb.WriteString("\tif g.Custom == nil {\n")
	sb.WriteString("\t\tg.Custom = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Custom[k] = v\n")
	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateWriteGlobalFunction(sb *strings.Builder, globalAttrs []spec.Attribute) {
	sb.WriteString("// Generated WriteGlobal function based on gostar global attributes\n")
	sb.WriteString("func WriteGlobal(sb *strings.Builder, g *GlobalAttrs) {\n")

	// Always include class attribute
	sb.WriteString("\tif g.Class != \"\" {\n")
	sb.WriteString("\t\tAttr(sb, \"class\", g.Class)\n")
	sb.WriteString("\t}\n")

	for _, attr := range globalAttrs {
		attrName := attr.Attr
		fieldName := attr.Field

		switch fieldName {
		case "Hidden", "Inert", "Autofocus", "Itemscope":
			fmt.Fprintf(sb, "\tif g.%s {\n", fieldName)
			fmt.Fprintf(sb, "\t\tBoolAttr(sb, \"%s\")\n", attrName)
			sb.WriteString("\t}\n")
		case "Tabindex":
			fmt.Fprintf(sb, "\tif g.%s != nil {\n", fieldName)
			fmt.Fprintf(sb, "\t\tAttr(sb, \"%s\", strconv.Itoa(*g.%s))\n", attrName, fieldName)
			sb.WriteString("\t}\n")
		case "Spellcheck", "Translate", "Draggable", "Writingsuggestions":
			fmt.Fprintf(sb, "\tif g.%s != nil {\n", fieldName)
			fmt.Fprintf(sb, "\t\tAttr(sb, \"%s\", *g.%s)\n", attrName, fieldName)
			sb.WriteString("\t}\n")
		default:
			fmt.Fprintf(sb, "\tif g.%s != \"\" {\n", fieldName)
			fmt.Fprintf(sb, "\t\tAttr(sb, \"%s\", g.%s)\n", attrName, fieldName)
			sb.WriteString("\t}\n")
		}
	}

	sb.WriteString("\t// Aria attributes\n")
	sb.WriteString("\tfor _, k := range sortedKeys(g.Aria) {\n")
	sb.WriteString("\t\tAttr(sb, \"aria-\"+k, g.Aria[k])\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// Data attributes\n")
	sb.WriteString("\tfor _, k := range sortedKeys(g.Data) {\n")
	sb.WriteString("\t\tAttr(sb, \"data-\"+k, g.Data[k])\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// Event handlers\n")
	sb.WriteString("\tfor _, evAttr := range sortedKeys(g.Events) {\n")
	sb.WriteString("\t\thandler := g.Events[evAttr]\n")
	sb.WriteString("\t\tif handler != \"\" {\n")
	sb.WriteString("\t\t\tAttr(sb, evAttr, handler)\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// Custom attributes\n")
	sb.WriteString("\tfor _, k := range sortedKeys(g.Custom) {\n")
	sb.WriteString("\t\tif v := g.Custom[k]; v != \"\" {\n")
	sb.WriteString("\t\t\tAttr(sb, k, v)\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n")

	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateSortedKeysFunction(sb *strings.Builder) {
	sb.WriteString("func sortedKeys(m map[string]string) []string {\n")
	sb.WriteString("\tif len(m) == 0 {\n")
	sb.WriteString("\t\treturn nil\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tkeys := make([]string, 0, len(m))\n")
	sb.WriteString("\tfor k := range m {\n")
	sb.WriteString("\t\tif k != \"\" {\n")
	sb.WriteString("\t\t\tkeys = append(keys, k)\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tsort.Strings(keys)\n")
	sb.WriteString("\treturn keys\n")
	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateGlobalOptionType(sb *strings.Builder) {
	sb.WriteString("// Global option: one glue impl for all tags (methods are added in tag files)\n")
	sb.WriteString("type Global struct {\n")
	sb.WriteString("\tf func(*GlobalAttrs)\n")
	sb.WriteString("}\n\n")

	sb.WriteString("// Do applies the global attribute function to GlobalAttrs (public for SVG package integration)\n")
	sb.WriteString("func (g Global) Do(ga *GlobalAttrs) {\n")
	sb.WriteString("\tg.f(ga)\n")
	sb.WriteString("}\n\n")

	// Add import check for SVG compatibility
	sb.WriteString("// Note: applySvg method will be added via build tags or separate file\n")
	sb.WriteString("// to avoid circular imports between html and svg packages\n\n")
}

func (g *GlobalGenerator) generateGlobalConstructors(sb *strings.Builder, globalAttrs []spec.Attribute) {
	booleanAttributes := map[string]bool{
		"hidden": true, "inert": true, "autofocus": true, "itemscope": true,
	}

	sb.WriteString("// Global attribute constructors\n")

	// Always include AClass constructor
	sb.WriteString("func AClass(v string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.addClass(v) }}\n")
	sb.WriteString("}\n\n")

	for _, attr := range globalAttrs {
		attrName := attr.Attr
		fieldName := attr.Field

		if attrName == "data_attributes" || attrName == "class" {
			continue // Skip class - already handled above
		}

		funcName := "A" + attr.Field // Use A prefix

		if booleanAttributes[attrName] {
			fmt.Fprintf(sb, "func %s() Global {\n", funcName)
			fmt.Fprintf(sb, "\treturn Global{func(g *GlobalAttrs) { g.%s = true }}\n", fieldName)
			sb.WriteString("}\n\n")
		} else {
			g.generateSpecialAttributeConstructor(sb, funcName, attrName, fieldName)
		}
	}
}

func (g *GlobalGenerator) generateSpecialAttributeConstructor(sb *strings.Builder, funcName, attrName, fieldName string) {
	switch attrName {
	case "class":
		fmt.Fprintf(sb, "func %s(v string) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.addClass(v) }}\n")
		sb.WriteString("}\n\n")
	case "tabindex":
		fmt.Fprintf(sb, "func %s(i int) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Tabindex = &i }}\n")
		sb.WriteString("}\n\n")
	case "draggable":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"false\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"true\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Draggable = &val }}\n")
		sb.WriteString("}\n\n")
	case "spellcheck":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"false\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"true\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Spellcheck = &val }}\n")
		sb.WriteString("}\n\n")
	case "translate":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"no\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"yes\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Translate = &val }}\n")
		sb.WriteString("}\n\n")
	case "writingsuggestions":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"false\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"true\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Writingsuggestions = &val }}\n")
		sb.WriteString("}\n\n")
	case "itemscope":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Itemscope = true }}\n")
		sb.WriteString("}\n\n")
	case "is":
		sb.WriteString("func AIsAttr(v string) Global {\n") // avoid collision with existing IsAttr
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Is = v }}\n")
		sb.WriteString("}\n\n")
	case "style":
		fmt.Fprintf(sb, "func %s(style string) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Style = style }}\n")
		sb.WriteString("}\n\n")
	default:
		if fieldName != "" {
			fmt.Fprintf(sb, "func %s(v string) Global {\n", funcName)
			fmt.Fprintf(sb, "\treturn Global{func(g *GlobalAttrs) { g.%s = v }}\n", fieldName)
			sb.WriteString("}\n\n")
		}
	}
}

func (g *GlobalGenerator) generateConvenienceFunctions(sb *strings.Builder) {
	sb.WriteString("// Map-like convenience functions\n")
	sb.WriteString("func AData(k, v string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setData(k, v) }}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func AAria(k, v string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setAria(k, v) }}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func AOn(ev, handler string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setEvent(ev, handler) }}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func ACustom(k, v string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setCustom(k, v) }}\n")
	sb.WriteString("}\n")
}

func (g *GlobalGenerator) contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
