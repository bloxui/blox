package generator

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/plainkit/html/cmd/gen-tags/internal/spec"
)

// GlobalGenerator handles generation of the core_global.go file
type GlobalGenerator struct{}

// NewGlobalGenerator creates a new global generator
func NewGlobalGenerator() *GlobalGenerator {
	return &GlobalGenerator{}
}

// GenerateSource creates the source code for core_global.go
func (g *GlobalGenerator) GenerateSource(globalAttrs []spec.Attribute) string {
	var sb strings.Builder

	sb.WriteString("package html\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"sort\"\n")
	sb.WriteString("\t\"strings\"\n")
	sb.WriteString(")\n\n")
	sb.WriteString("// This file is generated by gen-tags; DO NOT EDIT.\n")
	sb.WriteString("// Global HTML attributes structure and option constructors.\n\n")

	// Generate GlobalAttrs struct
	g.generateGlobalAttrsStruct(&sb)

	// Generate helper methods
	g.generateHelperMethods(&sb)

	// Generate WriteGlobal function
	g.generateWriteGlobalFunction(&sb, globalAttrs)

	// Generate sortedKeys helper
	g.generateSortedKeysFunction(&sb)

	// Generate Global option type
	g.generateGlobalOptionType(&sb)

	// Generate global attribute constructors
	g.generateGlobalConstructors(&sb, globalAttrs)

	// Generate map-like convenience functions
	g.generateConvenienceFunctions(&sb)

	return sb.String()
}

func (g *GlobalGenerator) generateGlobalAttrsStruct(sb *strings.Builder) {
	// Load global attributes from spec file
	globalSpec, err := g.loadGlobalAttributesSpec()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: Could not load global attributes spec: %v\n", err)
		g.generateGlobalAttrsStructFallback(sb)
		return
	}

	sb.WriteString("type GlobalAttrs struct {\n")
	sb.WriteString("\t// Generated from global_attributes.json spec\n")
	sb.WriteString("\t// Common core attributes\n")

	// Group attributes by type for better organization
	stringAttrs := []string{}
	boolAttrs := []string{}
	pointerStringAttrs := []string{"spellcheck", "translate", "draggable", "writingsuggestions"}
	pointerIntAttrs := []string{"tabindex"}

	// Process attributes from spec
	for attrName := range globalSpec.Html.GlobalAttributes {
		if attrName == "data_attributes" {
			continue // Skip data attributes - handled separately
		}

		fieldName := g.getFieldNameForAttribute(attrName)
		if fieldName == "" {
			continue // Skip unmapped
		}

		// Categorize by type
		if g.contains(pointerStringAttrs, attrName) {
			// Handled separately
		} else if g.contains(pointerIntAttrs, attrName) {
			// Handled separately
		} else if g.contains([]string{"hidden", "inert", "autofocus"}, attrName) {
			boolAttrs = append(boolAttrs, fieldName)
		} else if attrName == "style" {
			// Style handled separately
		} else {
			stringAttrs = append(stringAttrs, fieldName)
		}
	}

	// Add string attributes
	for _, field := range stringAttrs {
		fmt.Fprintf(sb, "\t%s string\n", field)
	}

	sb.WriteString("\n\t// Style attribute as a single string\n")
	sb.WriteString("\tStyle string\n\n")

	sb.WriteString("\t// Map attributes\n")
	sb.WriteString("\tAria   map[string]string // aria-*\n")
	sb.WriteString("\tData   map[string]string // data-*\n")
	sb.WriteString("\tEvents map[string]string // \"onclick\" -> \"handler()\"\n")
	sb.WriteString("\tCustom map[string]string // custom attributes like hx-*, x-*, etc.\n\n")

	sb.WriteString("\t// Pointers for tri-state values\n")
	sb.WriteString("\tTabIndex *int\n")
	sb.WriteString("\tSpellcheck, Translate, Draggable, WritingSuggestions *string\n\n")

	sb.WriteString("\t// Booleans\n")
	for i, field := range boolAttrs {
		if i == 0 {
			fmt.Fprintf(sb, "\t%s", field)
		} else {
			fmt.Fprintf(sb, ", %s", field)
		}
	}
	if len(boolAttrs) > 0 {
		sb.WriteString(" bool\n")
	}

	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateGlobalAttrsStructFallback(sb *strings.Builder) {
	sb.WriteString("type GlobalAttrs struct {\n")
	sb.WriteString("\t// Fallback structure - could not load spec\n")
	sb.WriteString("\tId, Class, Title string\n")
	sb.WriteString("\tStyle string\n")
	sb.WriteString("\tAria   map[string]string\n")
	sb.WriteString("\tData   map[string]string\n")
	sb.WriteString("\tEvents map[string]string\n")
	sb.WriteString("\tCustom map[string]string\n")
	sb.WriteString("\tHidden bool\n")
	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateHelperMethods(sb *strings.Builder) {
	sb.WriteString("// Helper methods for setting attributes\n")
	sb.WriteString("func (g *GlobalAttrs) addClass(v string) {\n")
	sb.WriteString("\tif v == \"\" {\n")
	sb.WriteString("\t\treturn\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tif g.Class == \"\" {\n")
	sb.WriteString("\t\tg.Class = v\n")
	sb.WriteString("\t} else {\n")
	sb.WriteString("\t\tg.Class += \" \" + v\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setStyle(style string) {\n")
	sb.WriteString("\tg.Style = style\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setAria(k, v string) {\n")
	sb.WriteString("\tif g.Aria == nil {\n")
	sb.WriteString("\t\tg.Aria = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Aria[k] = v\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setData(k, v string) {\n")
	sb.WriteString("\tif g.Data == nil {\n")
	sb.WriteString("\t\tg.Data = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Data[k] = v\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setEvent(ev, handler string) {\n")
	sb.WriteString("\tif g.Events == nil {\n")
	sb.WriteString("\t\tg.Events = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Events[\"on\"+ev] = handler\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g *GlobalAttrs) setCustom(k, v string) {\n")
	sb.WriteString("\tif g.Custom == nil {\n")
	sb.WriteString("\t\tg.Custom = map[string]string{}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tg.Custom[k] = v\n")
	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateWriteGlobalFunction(sb *strings.Builder, globalAttrs []spec.Attribute) {
	// Load global attributes from spec file
	globalSpec, err := g.loadGlobalAttributesSpec()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: Could not load global attributes spec: %v\n", err)
		g.generateWriteGlobalFallback(sb)
		return
	}

	sb.WriteString("// Generated WriteGlobal function based on global_attributes.json spec\n")
	sb.WriteString("func WriteGlobal(sb *strings.Builder, g *GlobalAttrs) {\n")

	// Generate attribute checks based on spec
	for attrName := range globalSpec.Html.GlobalAttributes {
		if attrName == "data_attributes" {
			continue // Handle data attributes separately
		}

		fieldName := g.getFieldNameForAttribute(attrName)
		if fieldName == "" {
			continue // Skip unmapped attributes
		}

		// Generate the appropriate check based on field type
		switch fieldName {
		case "Hidden", "Inert", "Autofocus", "ItemScope":
			// Boolean attributes
			fmt.Fprintf(sb, "\tif g.%s {\n", fieldName)
			fmt.Fprintf(sb, "\t\tBoolAttr(sb, \"%s\")\n", attrName)
			sb.WriteString("\t}\n")
		case "TabIndex":
			// Pointer to int
			fmt.Fprintf(sb, "\tif g.%s != nil {\n", fieldName)
			fmt.Fprintf(sb, "\t\tAttr(sb, \"%s\", itoa(*g.%s))\n", attrName, fieldName)
			sb.WriteString("\t}\n")
		case "Spellcheck", "Translate", "Draggable", "WritingSuggestions":
			// Pointer to string
			fmt.Fprintf(sb, "\tif g.%s != nil {\n", fieldName)
			fmt.Fprintf(sb, "\t\tAttr(sb, \"%s\", *g.%s)\n", attrName, fieldName)
			sb.WriteString("\t}\n")
		default:
			// Regular string attributes
			fmt.Fprintf(sb, "\tif g.%s != \"\" {\n", fieldName)
			fmt.Fprintf(sb, "\t\tAttr(sb, \"%s\", g.%s)\n", attrName, fieldName)
			sb.WriteString("\t}\n")
		}
	}

	// Add special handling for aria, data, events, custom
	sb.WriteString("\t// Aria attributes\n")
	sb.WriteString("\tfor _, k := range sortedKeys(g.Aria) {\n")
	sb.WriteString("\t\tAttr(sb, \"aria-\"+k, g.Aria[k])\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// Data attributes\n")
	sb.WriteString("\tfor _, k := range sortedKeys(g.Data) {\n")
	sb.WriteString("\t\tAttr(sb, \"data-\"+k, g.Data[k])\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// Event handlers\n")
	sb.WriteString("\tfor _, evAttr := range sortedKeys(g.Events) {\n")
	sb.WriteString("\t\thandler := g.Events[evAttr]\n")
	sb.WriteString("\t\tif handler != \"\" {\n")
	sb.WriteString("\t\t\tAttr(sb, evAttr, handler)\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// Custom attributes\n")
	sb.WriteString("\tfor _, k := range sortedKeys(g.Custom) {\n")
	sb.WriteString("\t\tif v := g.Custom[k]; v != \"\" {\n")
	sb.WriteString("\t\t\tAttr(sb, k, v)\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n")

	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateWriteGlobalFallback(sb *strings.Builder) {
	sb.WriteString("// Fallback WriteGlobal function - could not load spec\n")
	sb.WriteString("func WriteGlobal(sb *strings.Builder, g *GlobalAttrs) {\n")
	sb.WriteString("\t// Basic attributes only\n")
	sb.WriteString("\tif g.Id != \"\" {\n")
	sb.WriteString("\t\tAttr(sb, \"id\", g.Id)\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tif g.Class != \"\" {\n")
	sb.WriteString("\t\tAttr(sb, \"class\", g.Class)\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateSortedKeysFunction(sb *strings.Builder) {
	sb.WriteString("func sortedKeys(m map[string]string) []string {\n")
	sb.WriteString("\tif len(m) == 0 {\n")
	sb.WriteString("\t\treturn nil\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tkeys := make([]string, 0, len(m))\n")
	sb.WriteString("\tfor k := range m {\n")
	sb.WriteString("\t\tif k != \"\" {\n")
	sb.WriteString("\t\t\tkeys = append(keys, k)\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tsort.Strings(keys)\n")
	sb.WriteString("\treturn keys\n")
	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateGlobalOptionType(sb *strings.Builder) {
	sb.WriteString("// Global option: one glue impl for all tags (methods are added in tag files)\n")
	sb.WriteString("type Global struct {\n")
	sb.WriteString("\tf func(*GlobalAttrs)\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (g Global) do(ga *GlobalAttrs) {\n")
	sb.WriteString("\tg.f(ga)\n")
	sb.WriteString("}\n\n")
}

func (g *GlobalGenerator) generateGlobalConstructors(sb *strings.Builder, globalAttrs []spec.Attribute) {
	// Map HTML attribute names to GlobalAttrs field names
	fieldMap := g.getAttributeFieldMap()

	// Special attributes that have custom types or logic
	specialAttributes := map[string]bool{
		"class": true, "tabindex": true, "draggable": true, "spellcheck": true,
		"translate": true, "writingsuggestions": true, "itemscope": true,
		"is": true, "data_attributes": true, "style": true,
	}

	// Boolean attributes
	booleanAttributes := map[string]bool{
		"hidden": true, "inert": true, "autofocus": true, "itemscope": true,
	}

	// Global attribute constructors
	sb.WriteString("// Global attribute constructors\n")
	for _, attr := range globalAttrs {
		attrName := attr.Attr
		fieldName := fieldMap[attrName]

		// Skip attributes that don't map to GlobalAttrs fields
		if fieldName == "" && !specialAttributes[attrName] {
			continue
		}

		funcName := "A" + attr.Field // Use A prefix

		// Skip data_attributes - it's handled by AData function
		if attrName == "data_attributes" {
			continue
		}

		if booleanAttributes[attrName] {
			fmt.Fprintf(sb, "func %s() Global {\n", funcName)
			fmt.Fprintf(sb, "\treturn Global{func(g *GlobalAttrs) { g.%s = true }}\n", fieldName)
			sb.WriteString("}\n\n")
		} else {
			g.generateSpecialAttributeConstructor(sb, funcName, attrName, fieldName)
		}
	}
}

func (g *GlobalGenerator) generateSpecialAttributeConstructor(sb *strings.Builder, funcName, attrName, fieldName string) {
	// String attributes with special handling
	switch attrName {
	case "class":
		fmt.Fprintf(sb, "func %s(v string) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.addClass(v) }}\n")
		sb.WriteString("}\n\n")
	case "tabindex":
		fmt.Fprintf(sb, "func %s(i int) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.TabIndex = &i }}\n")
		sb.WriteString("}\n\n")
	case "draggable":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"false\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"true\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Draggable = &val }}\n")
		sb.WriteString("}\n\n")
	case "spellcheck":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"false\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"true\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Spellcheck = &val }}\n")
		sb.WriteString("}\n\n")
	case "translate":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"no\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"yes\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Translate = &val }}\n")
		sb.WriteString("}\n\n")
	case "writingsuggestions":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\tval := \"false\"\n")
		sb.WriteString("\tif b {\n")
		sb.WriteString("\t\tval = \"true\"\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.WritingSuggestions = &val }}\n")
		sb.WriteString("}\n\n")
	case "itemscope":
		fmt.Fprintf(sb, "func %s(b bool) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.ItemScope = b }}\n")
		sb.WriteString("}\n\n")
	case "is":
		sb.WriteString("func AIsAttr(v string) Global {\n") // avoid collision with existing IsAttr
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.Is = v }}\n")
		sb.WriteString("}\n\n")
	case "style":
		fmt.Fprintf(sb, "func %s(style string) Global {\n", funcName)
		sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setStyle(style) }}\n")
		sb.WriteString("}\n\n")
	default:
		// Standard string attribute
		if fieldName != "" {
			fmt.Fprintf(sb, "func %s(v string) Global {\n", funcName)
			fmt.Fprintf(sb, "\treturn Global{func(g *GlobalAttrs) { g.%s = v }}\n", fieldName)
			sb.WriteString("}\n\n")
		}
	}
}

func (g *GlobalGenerator) generateConvenienceFunctions(sb *strings.Builder) {
	sb.WriteString("// Map-like convenience functions\n")
	sb.WriteString("func AData(k, v string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setData(k, v) }}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func AAria(k, v string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setAria(k, v) }}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func AOn(ev, handler string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setEvent(ev, handler) }}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func ACustom(k, v string) Global {\n")
	sb.WriteString("\treturn Global{func(g *GlobalAttrs) { g.setCustom(k, v) }}\n")
	sb.WriteString("}\n")
}

// Helper methods
func (g *GlobalGenerator) loadGlobalAttributesSpec() (*spec.GlobalAttributesSpec, error) {
	data, err := os.ReadFile("specs/global_attributes.json")
	if err != nil {
		return nil, err
	}

	var spec spec.GlobalAttributesSpec
	if err := json.Unmarshal(data, &spec); err != nil {
		return nil, err
	}

	return &spec, nil
}

func (g *GlobalGenerator) getFieldNameForAttribute(attrName string) string {
	return g.getAttributeFieldMap()[attrName]
}

func (g *GlobalGenerator) getAttributeFieldMap() map[string]string {
	return map[string]string{
		"accesskey":             "AccessKey",
		"anchor":                "Anchor",
		"autocapitalize":        "AutoCapitalize",
		"autocorrect":           "AutoCorrect",
		"autofocus":             "Autofocus",
		"class":                 "Class",
		"contenteditable":       "ContentEditable",
		"dir":                   "Dir",
		"draggable":             "Draggable",
		"enterkeyhint":          "EnterKeyHint",
		"exportparts":           "ExportParts",
		"hidden":                "Hidden",
		"id":                    "Id",
		"inert":                 "Inert",
		"inputmode":             "InputMode",
		"is":                    "Is",
		"lang":                  "Lang",
		"nonce":                 "Nonce",
		"part":                  "Part",
		"popover":               "Popover",
		"slot":                  "Slot",
		"spellcheck":            "Spellcheck",
		"style":                 "Style",
		"tabindex":              "TabIndex",
		"title":                 "Title",
		"translate":             "Translate",
		"virtualkeyboardpolicy": "VirtualKeyboardPolicy",
		"writingsuggestions":    "WritingSuggestions",
		"itemscope":             "ItemScope",
	}
}

func (g *GlobalGenerator) contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
