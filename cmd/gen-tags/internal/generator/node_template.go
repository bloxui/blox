package generator

const nodeTemplate = `package html

// This file is generated by gen-tags; DO NOT EDIT.
// Core Node implementation and apply methods for all HTML elements.

import (
	"html"
	"strconv"
	"strings"
)

type Component interface {
	render(*strings.Builder)
}

type TextNode string

func (t TextNode) render(sb *strings.Builder) {
	sb.WriteString(html.EscapeString(string(t)))
}

type UnsafeTextNode string

func (t UnsafeTextNode) render(sb *strings.Builder) {
	sb.WriteString(string(t))
}

// attrWriter lets each tag write its own attributes (no central switch)
type attrWriter interface {
	writeAttrs(*strings.Builder)
}

type Node struct {
	Tag       string
	Attrs     any         // must implement attrWriter
	Kids      []Component // empty for void tags
	Void      bool
	AssetCSS  string // CSS to be collected by asset system
	AssetJS   string // JavaScript to be collected by asset system
	AssetName string // Name for asset deduplication
}

func (n Node) render(sb *strings.Builder) {
	sb.WriteString("<")
	sb.WriteString(n.Tag)
	if aw, ok := n.Attrs.(attrWriter); ok {
		aw.writeAttrs(sb)
	}
	sb.WriteString(">")
	if !n.Void {
		for _, k := range n.Kids {
			k.render(sb)
		}
		sb.WriteString("</")
		sb.WriteString(n.Tag)
		sb.WriteString(">")
	}
}

// Children exposes the node's children for traversals that need to walk
// the component tree (e.g., asset collection). This enables upstream
// code to discover nested components without callers having to pass
// them explicitly.
func (n Node) Children() []Component { return n.Kids }

// Asset interface implementations for Node
func (n Node) CSS() string  { return n.AssetCSS }
func (n Node) JS() string   { return n.AssetJS }
func (n Node) Name() string { return n.AssetName }

// WithAssets returns a copy of the Node with CSS/JS assets attached
func (n Node) WithAssets(css, js, name string) Node {
	return Node{
		Tag:       n.Tag,
		Attrs:     n.Attrs,
		Kids:      n.Kids,
		Void:      n.Void,
		AssetCSS:  css,
		AssetJS:   js,
		AssetName: name,
	}
}

func Render(c Component) string {
	var sb strings.Builder
	c.render(&sb)
	return sb.String()
}

func Attr(sb *strings.Builder, k, v string) {
	sb.WriteString(" ")
	sb.WriteString(k)
	sb.WriteString(` + "`" + `="` + "`" + `)
	sb.WriteString(html.EscapeString(v))
	sb.WriteString(` + "`" + `"` + "`" + `)
}

func BoolAttr(sb *strings.Builder, k string) {
	sb.WriteString(" ")
	sb.WriteString(k)
}

func itoa(i int) string {
	return strconv.Itoa(i)
}

// Allow passing any Component (Node) directly as a child argument to content tags,
// removing the need to wrap with Child(...)/C(...).
// Node implements many *Arg interfaces by appending itself to the children slice.

{{range .TagNames}}func (n Node) apply{{.}}(_ *{{.}}Attrs, kids *[]Component) { *kids = append(*kids, n) }
{{end}}

// TxtOpt and UnsafeTxtOpt apply methods for all HTML elements
{{range .TagNames}}func (o TxtOpt) apply{{.}}(_ *{{.}}Attrs, kids *[]Component) { *kids = append(*kids, TextNode(o.s)) }
{{end}}

{{range .TagNames}}func (o UnsafeTxtOpt) apply{{.}}(_ *{{.}}Attrs, kids *[]Component) { *kids = append(*kids, UnsafeTextNode(o.s)) }
{{end}}

// ChildOpt apply methods for all HTML elements
{{range .TagNames}}func (o ChildOpt) apply{{.}}(_ *{{.}}Attrs, kids *[]Component) { *kids = append(*kids, o.c) }
{{end}}`
